import json
import math
import tkinter as tk
from tkinter import Image, filedialog, messagebox
from lidar_map_drawer import draw_lidar_on_canvas, reset_lidar_map
from encoder_handler import get_robot_pose
from lidar_map_drawer import world_to_pixel, MAP_SIZE_PIXELS, MAP_SCALE

class MapTab(tk.Frame):
    def __init__(self, master, app):
        super().__init__(master, bg="white")
        self.app = app  # ƒë·ªÉ g·ªçi sang app khi c·∫ßn
        self.ogm_set = set()
        self.path_lines = []
        self.robot_goal = None
        self.robot_start = None

        tk.Label(self, text="B·∫¢N ƒê·ªí HO·∫†T ƒê·ªòNG C·ª¶A ROBOT",
                 font=("Arial", 20, "bold"), bg="white", fg="#2c3e50").pack(pady=10)

        # Main map canvas
        self.main_map = tk.Canvas(self, width=680, height=300, bg="#ecf0f1", highlightbackground="#bdc3c7")
        self.main_map.pack(pady=5)

        # Bottom: sub-map + control frame
        bottom_frame = tk.Frame(self, bg="white")
        bottom_frame.pack(fill="x", padx=10, pady=10)

        self.sub_map = tk.Canvas(bottom_frame, width=300, height=200, bg="#dfe6e9", highlightbackground="#bdc3c7")
        self.sub_map.pack(side="left", padx=5)

        control_frame = tk.Frame(bottom_frame, bg="white")
        control_frame.pack(side="left", fill="both", expand=True, padx=10)

        tk.Button(control_frame, text="üóÇ Ch·ªçn b·∫£n ƒë·ªì", font=("Arial", 11), width=20, command=self.select_map).pack(pady=4)
        tk.Button(control_frame, text="üóë Xo√° b·∫£n ƒë·ªì", font=("Arial", 11), width=20, command=self.clear_map).pack(pady=4)
        tk.Button(control_frame, text="‚úèÔ∏è V·∫Ω ƒë∆∞·ªùng ƒëi", font=("Arial", 11), width=20, command=self.draw_path).pack(pady=4)
        tk.Button(control_frame, text="‚ùå Xo√° ƒë∆∞·ªùng ƒëi", font=("Arial", 11), width=20, command=self.clear_path).pack(pady=4)
        tk.Button(control_frame, text="üéØ ƒê√≠ch ƒë·∫øn", font=("Arial", 11), width=20, command=self.set_goal_point).pack(pady=4)

        self.robot_status_label = tk.Label(control_frame, text="Tr·∫°ng th√°i: Di chuy·ªÉn", font=("Arial", 11, "bold"),
                                           bg="green", fg="white", width=20)
        self.robot_status_label.pack(pady=10)

        # === C√°c h√†m x·ª≠ l√Ω tab b·∫£n ƒë·ªì ===
    def select_map(self):
        import os, json, math, time
        from tkinter import filedialog
        from PIL import ImageTk, ImageDraw, Image
        from lidar_map_drawer import (
            MAP_SIZE_PIXELS, MAP_SCALE,
            reset_lidar_map, global_map_image, global_draw, drawn_points
        )

        def frange(start, stop, step):
            while start <= stop:
                yield start
                start += step

        def scan_to_points(scan_data):
            angle = scan_data["angle_min"]
            angle_inc = scan_data["angle_increment"]
            ranges = scan_data["ranges"]
            points = []
            for r in ranges:
                if 0.1 < r < 6.0:
                    x = r * math.cos(angle)
                    y = r * math.sin(angle)
                    points.append((x, y))
                angle += angle_inc
            return points

        def compute_matching_score(scan_points, ogm_set, tx, ty, theta):
            score = 0
            cos_t = math.cos(theta)
            sin_t = math.sin(theta)
            for x, y in scan_points:
                x_map = x * cos_t - y * sin_t + tx
                y_map = x * sin_t + y * cos_t + ty
                px = int(x_map * MAP_SCALE + MAP_SIZE_PIXELS // 2)
                py = int(MAP_SIZE_PIXELS // 2 - y_map * MAP_SCALE)
                if (px, py) in ogm_set:
                    score += 1
            return score

        def find_best_pose(scan_data, ogm_set):
            scan_points = scan_to_points(scan_data)
            best_score = -1
            best_pose = (0, 0, 0)
            for tx in frange(-2, 2, 0.1):
                for ty in frange(-2, 2, 0.1):
                    for theta in frange(-math.pi, math.pi, math.radians(15)):
                        score = compute_matching_score(scan_points, ogm_set, tx, ty, theta)
                        if score > best_score:
                            best_score = score
                            best_pose = (tx, ty, theta)
            print(f"‚úÖ Best match: {best_pose} v·ªõi score = {best_score}")
            return best_pose

        file_path = filedialog.askopenfilename(
            filetypes=[("JSON Map or Scan", "*.json")]
        )
        if not file_path:
            return

        canvas = getattr(self, "main_map", None)
        if canvas:
            canvas.delete("all")
        try:
            with open(file_path, "r") as f:
                data = json.load(f)

            if "occupied_points" not in data:
                print("‚ö†Ô∏è File JSON kh√¥ng ch·ª©a b·∫£n ƒë·ªì OGM!")
                return

            reset_lidar_map(canvas)
            drawn_points.clear()
            ogm_set = set(tuple(p) for p in data["occupied_points"])
            for px, py in ogm_set:
                if 0 <= px < MAP_SIZE_PIXELS and 0 <= py < MAP_SIZE_PIXELS:
                    global_draw.ellipse((px - 1, py - 1, px + 1, py + 1), fill="black")
                    drawn_points.add((px, py))
            print("‚úÖ ƒê√£ hi·ªÉn th·ªã b·∫£n ƒë·ªì OGM.")

            # L∆∞u l·∫°i OGM set ƒë·ªÉ callback kh√°c c√≥ th·ªÉ d√πng
            self.ogm_set = ogm_set

            # --- L·∫•y LiDAR scan m·ªõi nh·∫•t ---
            scan = getattr(self, "last_lidar_scan", None)
            print("DEBUG | LiDAR scan nh·∫≠n ƒë∆∞·ª£c:", scan)
            if scan and isinstance(scan, dict) and "ranges" in scan:
                best_x, best_y, best_theta = find_best_pose(scan, ogm_set)
                px = int(best_x * MAP_SCALE + MAP_SIZE_PIXELS // 2)
                py = int(MAP_SIZE_PIXELS // 2 - best_y * MAP_SCALE)
                global_draw.ellipse((px - 4, py - 4, px + 4, py + 4), fill="red")
                print(f"üìç ƒê√£ v·∫Ω v·ªã tr√≠ robot l√™n OGM t·∫°i ({px}, {py}) (m: {best_x:.2f}, {best_y:.2f})")
            else:
                print("‚ö†Ô∏è Ch∆∞a c√≥ v√≤ng qu√©t LiDAR ƒë·ªÉ ƒë·ªãnh v·ªã robot!")
                print("‚ö†Ô∏è G·ª£i √Ω: Ch·∫°y robot Pi4, ƒë·ª£i nh·∫≠n d·ªØ li·ªáu LiDAR, r·ªìi b·∫•m l·∫°i 'Ch·ªçn b·∫£n ƒë·ªì'.")

            # Hi·ªÉn th·ªã l·∫°i ·∫£nh l√™n canvas
            img_resized = global_map_image.resize((canvas.winfo_width(), canvas.winfo_height()))
            tk_img = ImageTk.PhotoImage(img_resized)
            canvas.map_image = canvas.create_image(0, 0, anchor="nw", image=tk_img)
            canvas.image = tk_img
            self.lidar_image = global_map_image.copy()

        except Exception as e:
            print(f"‚ùå L·ªói khi ƒë·ªçc ho·∫∑c x·ª≠ l√Ω JSON: {e}")



    def clear_map(self):
        print("üóë ƒê√£ xo√° b·∫£n ƒë·ªì ch√≠nh!")
        # Xo√° to√†n b·ªô ƒë·ªëi t∆∞·ª£ng tr√™n canvas b·∫£n ƒë·ªì ch√≠nh 
        if hasattr(self, "main_map"):
            self.main_map.delete("all")
        # Xo√° bi·∫øn l∆∞u ·∫£nh b·∫£n ƒë·ªì ch√≠nh trong app
        self.map_image = None
        self.lidar_image = None
        self.last_lidar_data = None
        # Reset l·∫°i b·∫£n ƒë·ªì t√≠ch l≈©y (n·∫øu b·∫°n d√πng ·∫£nh to√†n c·ª•c v·∫Ω t√≠ch l≈©y)
        from lidar_map_drawer import reset_lidar_map
        reset_lidar_map(self.main_map)
        # Th√¥ng b√°o popup cho user
        from tkinter import messagebox
        messagebox.showinfo("Xo√° b·∫£n ƒë·ªì", "B·∫£n ƒë·ªì ch√≠nh ƒë√£ ƒë∆∞·ª£c xo√° kh·ªèi giao di·ªán.")



    def draw_path(self):
        from encoder_handler import get_robot_pose
        from lidar_map_drawer import world_to_pixel, MAP_SIZE_PIXELS
        import math

        canvas = self.main_map
        if not canvas or not hasattr(self, "ogm_set"):
            print("‚ö†Ô∏è Ch∆∞a c√≥ b·∫£n ƒë·ªì OGM ƒë·ªÉ v·∫Ω ƒë∆∞·ªùng.")
            return

        # 1. X√≥a overlay c≈© n·∫øu c√≥
        if hasattr(self, "path_items"):
            for item in self.path_items:
                canvas.delete(item)
        self.path_items = []

        # 2. L·∫•y v·ªã tr√≠ robot hi·ªán t·∫°i (t√≠nh theo encoder)
        try:
            x, y, theta = get_robot_pose()[:3]
        except Exception as e:
            print("‚ùå Kh√¥ng th·ªÉ l·∫•y v·ªã tr√≠ robot t·ª´ encoder:", e)
            return

        # 3. Chuy·ªÉn sang pixel ·∫£nh ‚Üí pixel canvas
        px, py = world_to_pixel(x, y)
        canvas_w = canvas.winfo_width()
        canvas_h = canvas.winfo_height()
        cx = px * canvas_w / MAP_SIZE_PIXELS
        cy = py * canvas_h / MAP_SIZE_PIXELS

        # 4. V·∫Ω ƒëi·ªÉm ƒë·∫ßu (m√†u ƒë·ªè) v√† l∆∞u l·∫°i
        r = 4
        dot = canvas.create_oval(cx - r, cy - r, cx + r, cy + r, fill="red", outline="")
        self.path_items = [dot]
        self._last_path_xy = (cx, cy)

        print(f"üö© V·ªã tr√≠ robot b·∫Øt ƒë·∫ßu: ({x:.2f}, {y:.2f}) ‚Üí canvas ({cx:.1f}, {cy:.1f})")
        print("‚úèÔ∏è Click t·ª´ng ƒëi·ªÉm tr√™n b·∫£n ƒë·ªì ƒë·ªÉ n·ªëi ƒë∆∞·ªùng ƒëi...")

        # 5. G·∫Øn s·ª± ki·ªán click v√†o canvas
        def on_canvas_click(event):
            x1, y1 = self._last_path_xy
            x2, y2 = event.x, event.y

            # V·∫Ω ƒëo·∫°n th·∫≥ng
            line = canvas.create_line(x1, y1, x2, y2, fill="blue", width=2)
            # V·∫Ω ƒëi·ªÉm tr√≤n
            dot = canvas.create_oval(x2 - 3, y2 - 3, x2 + 3, y2 + 3, fill="green", outline="")

            self.path_items += [line, dot]
            self._last_path_xy = (x2, y2)

            print(f"‚ûï ƒê√£ th√™m ƒëi·ªÉm ({x2}, {y2}) tr√™n canvas")

        # 6. K·∫øt n·ªëi s·ª± ki·ªán click chu·ªôt
        canvas.bind("<Button-1>", on_canvas_click)



    def draw_robot_pose(x, y, theta, draw_obj):
        px, py = world_to_pixel(x, y)

        # V·∫Ω th√¢n robot (ch·∫•m ƒë·ªè)
        draw_obj.ellipse((px - 5, py - 5, px + 5, py + 5), fill="red")

        # V·∫Ω m≈©i t√™n ch·ªâ h∆∞·ªõng robot
        arrow_len = 20
        end_x = px + arrow_len * math.cos(theta)
        end_y = py - arrow_len * math.sin(theta)  # Tr·ª•c y ƒë·∫£o
        draw_obj.line((px, py, end_x, end_y), fill="green", width=2)




    def set_goal_point(self):
        print("üî¥ H√£y click v√†o b·∫£n ƒë·ªì ƒë·ªÉ ch·ªçn v·ªã tr√≠ ƒë√≠ch ƒë·∫øn.")

        def on_click(event):
            canvas = self.main_map

            # Ki·ªÉm tra canvas h·ª£p l·ªá
            if not canvas or not canvas.winfo_exists():
                print("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y canvas b·∫£n ƒë·ªì.")
                return

            canvas_width = canvas.winfo_width()
            canvas_height = canvas.winfo_height()

            # V·ªã tr√≠ pixel click
            click_x = event.x
            click_y = event.y

            # Chuy·ªÉn sang to·∫° ƒë·ªô th·ª±c t·∫ø (m√©t)
            from lidar_map_drawer import MAP_SCALE, MAP_SIZE_PIXELS

            x_pixel = (click_x / canvas_width) * MAP_SIZE_PIXELS
            y_pixel = (click_y / canvas_height) * MAP_SIZE_PIXELS

            real_x = (x_pixel - MAP_SIZE_PIXELS / 2) / MAP_SCALE
            real_y = (MAP_SIZE_PIXELS / 2 - y_pixel) / MAP_SCALE

            # L∆∞u l·∫°i v·ªã tr√≠ ƒë√≠ch
            self.robot_goal = (real_x, real_y)
            print(f"üéØ ƒê√≠ch ƒë·∫øn ƒë∆∞·ª£c ƒë·∫∑t t·∫°i: x = {real_x:.2f} m, y = {real_y:.2f} m")

            # X√≥a ƒëi·ªÉm c≈© n·∫øu c√≥
            if hasattr(self, "goal_dot"):
                canvas.delete(self.goal_dot)

            # V·∫Ω ƒëi·ªÉm ƒë·ªè t·∫°i v·ªã tr√≠ chu·ªôt
            r = 5
            self.goal_dot = canvas.create_oval(click_x - r, click_y - r, click_x + r, click_y + r,
                                            fill="red", outline="black")

            # H·ªßy b·∫Øt s·ª± ki·ªán sau khi click
            canvas.unbind("<Button-1>")

        # B·∫Øt ƒë·∫ßu l·∫Øng nghe click chu·ªôt tr√°i
        self.main_map.bind("<Button-1>", on_click)

    def clear_path(self):
        if not hasattr(self, "main_map"):
            print("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y canvas ƒë·ªÉ xo√° ƒë∆∞·ªùng ƒëi.")
            return

        # Xo√° c√°c ƒëo·∫°n line ƒë∆∞·ªùng ƒëi ƒë√£ l∆∞u
        for line in getattr(self, "path_lines", []):
            self.main_map.delete(line)
        self.path_lines = []

        if hasattr(self, "goal_dot"):
            self.main_map.delete(self.goal_dot)
            del self.goal_dot

        # Xo√° bi·∫øn v·ªã tr√≠ start/goal n·∫øu mu·ªën (t√πy b·∫°n)
        self.robot_start = None
        self.robot_goal = None
        print("üßπ ƒê√£ xo√° ƒë∆∞·ªùng ƒëi.")

    def update_robot_position_on_loaded_map(self):
            from lidar_map_drawer import draw_robot_realtime
            if hasattr(self, "lidar_image") and hasattr(self, "main_map"):
                draw_robot_realtime(self.main_map, self.lidar_image)
            if hasattr(self, "root"):
                self.root.after(300, self.update_robot_position_on_loaded_map)

    def show_png_on_map(self, file_path):
        try:
            image = Image.open(file_path)
            image = image.resize((680, 300), Image.Resampling.LANCZOS)
            self.map_image = Image.PhotoImage(image)
            # X√ìA CANVAS tr∆∞·ªõc khi v·∫Ω m·ªõi (c·ª±c k·ª≥ quan tr·ªçng!)
            self.main_map.delete("all")
            # LU√îN t·∫°o l·∫°i image m·ªõi!
            self.main_map.create_image(0, 0, anchor="nw", image=self.map_image)
            print(f"üñº ƒê√£ ch·ªçn b·∫£n ƒë·ªì: {file_path}")
        except Exception as e:
            print("‚ùå L·ªói khi m·ªü b·∫£n ƒë·ªì PNG:", e)

    def draw_ogm_from_json(self, data):
            from lidar_map_drawer import global_map_image, global_draw, drawn_points, MAP_SIZE_PIXELS
            from PIL import ImageTk

            if "occupied_points" not in data:
                print("‚ö†Ô∏è Kh√¥ng c√≥ d·ªØ li·ªáu occupied_points!")
                return

            self.ogm_set = set(tuple(p) for p in data["occupied_points"])
            reset_lidar_map(self.main_map)
            drawn_points.clear()

            for px, py in self.ogm_set:
                if 0 <= px < MAP_SIZE_PIXELS and 0 <= py < MAP_SIZE_PIXELS:
                    global_draw.ellipse((px - 1, py - 1, px + 1, py + 1), fill="black")
                    drawn_points.add((px, py))

            img_resized = global_map_image.resize((self.main_map.winfo_width(), self.main_map.winfo_height()))
            tk_img = ImageTk.PhotoImage(img_resized)
            self.main_map.map_image = self.main_map.create_image(0, 0, anchor="nw", image=tk_img)
            self.main_map.image = tk_img

            self.lidar_image = global_map_image.copy()
            print("‚úÖ ƒê√£ hi·ªÉn th·ªã b·∫£n ƒë·ªì OGM.")
            

    def load_lidar_map_from_file(self, json_path):
        with open(json_path, "r") as f:
            data = json.load(f)
        # Chuy·ªÉn None (trong ranges) th√†nh math.inf ƒë·ªÉ t√°i s·ª≠ d·ª•ng v·∫Ω l·∫°i
        ranges = []
        for v in data["ranges"]:
            if v is None:
                ranges.append(float("inf"))
            else:
                ranges.append(v)
        data["ranges"] = ranges

        # V·∫Ω l·∫°i l√™n canvas
        if hasattr(self, "scan_canvas") and self.scan_canvas.winfo_exists():
            draw_lidar_on_canvas(self.scan_canvas, data)
            print(f"[App] üñºÔ∏è ƒê√£ t·∫£i l·∫°i b·∫£n ƒë·ªì t·ª´: {json_path}")
        # N·∫øu mu·ªën l∆∞u l·∫°i v√†o self.last_lidar_data c≈©ng ƒë∆∞·ª£c:
        self.last_lidar_data = data        

    def update_robot_status(self, status):
        if status == "moving":
            self.robot_status_label.config(text="Tr·∫°ng th√°i: Di chuy·ªÉn", bg="green")
        elif status == "stuck":
            self.robot_status_label.config(text="Tr·∫°ng th√°i: M·∫Øc k·∫πt", bg="red")

